#!pigshell

usage=<<EOH
xray         -- Inspect pipeline

Usage:
    xray [-n <items>] [-y <sec>]
    xray -h | --help

Options:
    -h --help   Show this message.
    -y          Pass if not stopped in <sec>. 0 to pass, -1 to inspect
    -n <items>  Buffer upto <items> objects
EOH

HTML=<<EOH
<!DOCTYPE html>
<html>

<head>
    <link href="http://pigshell.com/v/0.6.2/pigshell.css" rel="stylesheet"/>
    <style>

        button.radio {
            background-color: red;
            text-align: center;
        }
        button.radio.selected {
            background-color: green;
        }

        thead, tfoot {
            background-color: #ddd;
        }
    </style>
</head>

<body>
    <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
    <script src="http://pigshell.com/extra/pframe.v0.js"></script>
    <script src="http://pigshell.com/common/d3.v3/d3.v3.min.js"></script>

    <div class="control">
        <button name="mode" class="control">Batch Mode</button>
        <button name="control" class="control">Pass Batch</button>
    </div>
    <table>
        <tbody>
        </tbody>
        <tfoot>
            <tr>
                <td></td>
                <td>Passed</td>
                <td></td>
            </tr>
        </tfoot>
    </table>

    <script type="text/javascript">

    var defaults = {
        nitems: 5,
        speed: 2,
        pass: true
    };

    var items = [],
        settings = defaults,
        state = {
            batch_mode: true,
            next_pending: false,
            unext_pending: false,
            running: false,
            num: 0,
            last_out: 0,
            height: get_height()
        },
        body = d3.select('body');

    pframe.onnext = function() {
        if (state.next_pending) {
            return exit("Unexpected next!");
        }
        state.next_pending = true;
        return update();
    };
    
    function getnext() {
        state.unext_pending = true;
        pframe.unext(function(res) {
            state.unext_pending = false;
            if (res === null) {
                items.unshift({key: -1, value: "<EOF>", sel: true, obj: null, pass: true});
            } else {
                items.unshift({key: state.num, item: obj2html(res),
                    sel: settings.pass, obj: res, pass: false});
                state.num++;
            }
            return update();
        });
    }

    pframe.onconfig = function(config) {
        settings = $.extend({}, defaults, config);
    };

    function update() {
        var time = Date.now(),
            next_out = state.last_out + settings.speed * 1000;

        if (!state.batch_mode && !state.running) {
            /* continuous mode, paused */
        } else if (!state.batch_mode && time < next_out) {
            /* continuous mode, running, but not yet time */
            state.tid = set_timeout(update, next_out - time + 100);
        } else if (state.next_pending) {
            /* output one item at most */
            while (items.length) {
                var item = items[items.length - 1];
                if (state.batch_mode && !item.pass) {
                    break;
                }
                items.pop();
                if (item.sel) {
                    state.next_pending = false;
                    state.last_out = time;
                    if (item.obj === null) {
                        return exit(true);
                    } else {
                        pframe.output(item.obj);
                        break;
                    }
                }
            }
        }
        update_view();
        if ((state.batch_mode || state.running) && !state.unext_pending
            && items.length < settings.nitems) {
            getnext();
        }
    }

    var table = d3.select("tbody");

    function update_view() {
        function getkey(d) {
            return d && d.key;
        }
        var rows =
            table.selectAll("tr")
                .data(items, getkey);

        rows.enter().append("tr");

        var cells =
            rows.selectAll("td")
                .data(function(d) {
                    if (!d) {
                        return d;
                    }
                    var b = '<button class="radio ' + (d.sel ? "selected" : "") +
                        '"></button>';
                    return [{key: 'item', value: d['item']},
                            {key: 'sel', value: b}];
                }, getkey);

        cells.enter().append("td");

        cells.html(function(d) {
            return d.value;
        });

        table.selectAll("tr").selectAll("button")
            .on("click", function(d, i, j) {
                var obj = items[j];
                obj.sel = !obj.sel;
                console.log("CLICK", d, i, j, obj);
                return update_view();
            });
            
        rows.exit().remove();

        var newheight = get_height();
        if (state.height < newheight) {
            state.height = newheight;
            pframe.config({height: newheight});
        }
    }

    $("button[name=mode]").on("click", function() {
        state.batch_mode = !state.batch_mode;

        if (state.batch_mode) {
            $(this).text("Batch Mode");
            $("button[name=control]").text("Pass Batch");
        } else {
            state.running = false;
            $(this).text("Flow Mode");
            $("button[name=control]").text("Run");
        }
    });
    $("button[name=control]").on("click", function() {
        if (state.batch_mode) {
            items.forEach(function(el) {
                el.pass = true;
            });
        } else {
            state.running = !state.running;
            $(this).text(state.running ? "Pause" : "Run");
        }
        update();
    });

    function obj2html(obj) {
        if (obj.html) {
            return obj.html;
        } else {
            return '<p>' + obj.toString() + '</p>';
        }
    }

    function get_height() {
        var myheight = document.documentElement.scrollHeight ||
            document.body.scrollHeight;

        return myheight;
    }

    function set_timeout(f, t) {
        if (state.tid) {
            console.log('timeout already set!');
            return;
        }
        state.tid = setTimeout(function() {
            state.tid = null;
            f();
        }, t);
    }

    pframe.config({height: get_height()});

    function exit(val) {
        if (state.tid) {
            clearTimeout(state.tid);
            state.tid = null;
        }
        document.body.innerHTML = '';
        pframe.config({height: get_height()});
        return pframe.exit(val);
    }
    </script>

</body>

</html>

EOH
jframe -s $HTML
